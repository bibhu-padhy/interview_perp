# Complete Coding Patterns Question Bank - Beginner to Advanced

## ðŸ”¹ 1. FREQUENCY MAP / HASH MAP PATTERN

### **Beginner Level**
1. **Two Sum** - Find two numbers that add up to target
2. **Valid Anagram** - Check if two strings are anagrams
3. **Contains Duplicate** - Check if array has duplicates
4. **First Unique Character** - Find first non-repeating character
5. **Majority Element** - Find element appearing more than n/2 times
6. **Single Number** - Find the number that appears once
7. **Intersection of Two Arrays** - Find common elements
8. **Happy Number** - Determine if number leads to 1
9. **Isomorphic Strings** - Check if strings follow same pattern
10. **Word Pattern** - Match pattern with words

### **Intermediate Level**
11. **Group Anagrams** - Group strings that are anagrams
12. **Top K Frequent Elements** - Find k most frequent elements
13. **Valid Sudoku** - Check if Sudoku board is valid
14. **Longest Substring Without Repeating Characters** - Using frequency map
15. **4Sum II** - Count tuples with zero sum
16. **Subarray Sum Equals K** - Count subarrays with given sum
17. **Contiguous Array** - Find longest subarray with equal 0s and 1s
18. **Find All Anagrams in String** - Find all anagram substrings
19. **Minimum Window Substring** - Find smallest window containing all chars
20. **Longest Palindrome** - Build longest palindrome from characters

### **Advanced Level**
21. **Substring with Concatenation of All Words** - Find substrings with all words
22. **First Missing Positive** - Find smallest missing positive integer
23. **Insert Delete GetRandom O(1)** - Design data structure
24. **LRU Cache** - Implement LRU cache using hash map
25. **Design Twitter** - Design Twitter-like system
26. **Alien Dictionary** - Find order of characters in alien language
27. **Maximum Frequency Stack** - Design stack with frequency operations
28. **Time Based Key-Value Store** - Design time-based data structure
29. **Random Pick with Blacklist** - Pick random excluding blacklisted
30. **Shortest Path to Get All Keys** - BFS with state tracking

---

## ðŸ”¹ 2. TWO POINTERS PATTERN

### **Beginner Level**
1. **Two Sum II - Input array is sorted** - Find two numbers with target sum
2. **Valid Palindrome** - Check if string is palindrome
3. **Remove Duplicates from Sorted Array** - Remove duplicates in-place
4. **Merge Sorted Array** - Merge two sorted arrays
5. **Move Zeroes** - Move all zeros to end
6. **Reverse String** - Reverse string in-place
7. **Reverse Words in String III** - Reverse each word
8. **Array Partition I** - Maximize sum of min pairs
9. **Squares of Sorted Array** - Square elements and sort
10. **Sort Colors** - Dutch flag problem

### **Intermediate Level**
11. **3Sum** - Find all unique triplets with zero sum
12. **3Sum Closest** - Find triplet closest to target
13. **4Sum** - Find all unique quadruplets with target sum
14. **Container With Most Water** - Find container with max area
15. **Trapping Rain Water** - Calculate trapped rainwater
16. **Sort Array By Parity** - Move even numbers to front
17. **Partition Labels** - Partition string into max parts
18. **Minimum Size Subarray Sum** - Find minimum subarray with target sum
19. **3Sum Smaller** - Count triplets with sum less than target
20. **Remove Element** - Remove all instances of value

### **Advanced Level**
21. **Longest Mountain in Array** - Find longest mountain subarray
22. **Push Dominoes** - Calculate final state of dominoes
23. **Boats to Save People** - Minimum boats needed
24. **Shortest Subarray with Sum at Least K** - Using deque
25. **Subarrays with K Different Integers** - Count subarrays
26. **Minimum Window Subsequence** - Find minimum window
27. **Longest Substring with At Most K Distinct Characters**
28. **Fruit Into Baskets** - Pick fruits with two types
29. **Get Equal Substrings Within Budget** - Max length within budget
30. **Number of Subsequences That Satisfy Sum Condition**

---

## ðŸ”¹ 3. SLIDING WINDOW PATTERN

### **Beginner Level**
1. **Maximum Average Subarray I** - Find max average of k elements
2. **Minimum Size Subarray Sum** - Find minimum length subarray
3. **Longest Substring Without Repeating Characters** - Basic sliding window
4. **Permutation in String** - Check if s2 contains permutation of s1
5. **Find All Anagrams in String** - Find all anagram substrings
6. **Longest Repeating Character Replacement** - With k replacements
7. **Max Consecutive Ones III** - With k flips
8. **Grumpy Bookstore Owner** - Maximize satisfied customers
9. **Sliding Window Maximum** - Maximum in each window
10. **Minimum Window Substring** - Smallest window with all characters

### **Intermediate Level**
11. **Longest Substring with At Most Two Distinct Characters**
12. **Longest Substring with At Most K Distinct Characters**
13. **Subarrays with K Different Integers** - Exact k distinct
14. **Fruit Into Baskets** - At most 2 types
15. **Get Equal Substrings Within Budget** - Within cost limit
16. **Replace the Substring for Balanced String** - Make string balanced
17. **Count Number of Nice Subarrays** - Odd numbers count
18. **Binary Subarrays With Sum** - Subarrays with target sum
19. **Subarray Product Less Than K** - Product condition
20. **Longest Turbulent Subarray** - Alternating comparisons

### **Advanced Level**
21. **Substring with Concatenation of All Words** - All words exactly once
22. **Minimum Window Subsequence** - Smallest subsequence window
23. **Shortest Subarray with Sum at Least K** - Using deque optimization
24. **Subarrays with K Different Integers** - Complex sliding window
25. **Number of Substrings Containing All Three Characters**
26. **Count Subarrays Where Max Element Appears K Times**
27. **Longest Subarray with Absolute Diff Less Than Limit**
28. **Constrained Subsequence Sum** - With constraint distance
29. **Sliding Window Median** - Median in sliding window
30. **Maximum Points from Cards** - Pick from ends

---

## ðŸ”¹ 4. FAST & SLOW POINTERS (CYCLE DETECTION)

### **Beginner Level**
1. **Linked List Cycle** - Detect if cycle exists
2. **Linked List Cycle II** - Find where cycle begins
3. **Happy Number** - Detect cycle in number sequence
4. **Find the Duplicate Number** - Find duplicate in array
5. **Middle of Linked List** - Find middle node
6. **Remove Nth Node From End** - Remove nth from end
7. **Palindrome Linked List** - Check if palindrome
8. **Intersection of Two Linked Lists** - Find intersection point
9. **Remove Duplicates from Sorted List** - Remove duplicates
10. **Merge Two Sorted Lists** - Merge two lists

### **Intermediate Level**
11. **Reorder List** - Reorder L0â†’Lnâ†’L1â†’Ln-1â†’...
12. **Add Two Numbers** - Add numbers represented as lists
13. **Swap Nodes in Pairs** - Swap every two adjacent nodes
14. **Rotate List** - Rotate list to the right
15. **Partition List** - Partition around value x
16. **Sort List** - Sort linked list in O(n log n)
17. **Copy List with Random Pointer** - Deep copy with random pointers
18. **Flatten Multilevel Doubly Linked List** - Flatten nested list
19. **Insert into Sorted Circular Linked List** - Insert maintaining order
20. **Split Linked List in Parts** - Split into k parts

### **Advanced Level**
21. **Reverse Nodes in k-Group** - Reverse every k nodes
22. **Merge k Sorted Lists** - Merge multiple sorted lists
23. **LRU Cache** - Implement using doubly linked list
24. **Design Browser History** - Navigate browser history
25. **All O`one Data Structure** - Support all operations in O(1)
26. **Design Skiplist** - Implement skip list data structure
27. **Convert Binary Search Tree to Sorted Doubly Linked List**
28. **Flatten Binary Tree to Linked List** - In-place flattening
29. **Clone Graph** - Deep clone connected graph
30. **Design Phone Directory** - Manage phone numbers

---

## ðŸ”¹ 5. STACK PATTERN

### **Beginner Level**
1. **Valid Parentheses** - Check balanced parentheses
2. **Min Stack** - Stack with min operation
3. **Implement Queue using Stacks** - Queue using two stacks
4. **Implement Stack using Queues** - Stack using queues
5. **Baseball Game** - Calculate final score
6. **Next Greater Element I** - Find next greater elements
7. **Backspace String Compare** - Compare with backspaces
8. **Remove Outermost Parentheses** - Remove outer parentheses
9. **Build Array With Stack Operations** - Build target array
10. **Make String Great** - Remove adjacent different case

### **Intermediate Level**
11. **Daily Temperatures** - Days until warmer temperature
12. **Next Greater Element II** - Circular array
13. **Asteroid Collision** - Simulate asteroid collisions
14. **Decode String** - Decode k[encoded_string]
15. **Remove K Digits** - Remove k digits for smallest number
16. **Validate Stack Sequences** - Check if valid pop sequence
17. **Score of Parentheses** - Calculate score of parentheses
18. **Remove All Adjacent Duplicates** - Remove duplicates
19. **Minimum Remove to Make Valid Parentheses** - Min removals
20. **Online Stock Span** - Calculate stock span

### **Advanced Level**
21. **Largest Rectangle in Histogram** - Max rectangle area
22. **Maximal Rectangle** - Max rectangle in binary matrix
23. **Trapping Rain Water** - Using stack approach
24. **Basic Calculator** - Evaluate expression with +, -, (, )
25. **Basic Calculator II** - With *, / operations
26. **Expression Add Operators** - Add operators to get target
27. **Remove Duplicate Letters** - Remove duplicates lexicographically
28. **Monotonic Stack** - Maintain monotonic property
29. **Car Fleet** - Calculate car fleets
30. **Maximum Frequency Stack** - Pop most frequent element

---

## ðŸ”¹ 6. BINARY SEARCH PATTERN

### **Beginner Level**
1. **Binary Search** - Basic binary search
2. **Search Insert Position** - Find insert position
3. **First Bad Version** - Find first bad version
4. **Sqrt(x)** - Integer square root
5. **Valid Perfect Square** - Check if perfect square
6. **Two Sum II - Input array is sorted** - Using binary search
7. **Intersection of Two Arrays II** - Find intersection
8. **Peak Index in Mountain Array** - Find peak element
9. **Find Smallest Letter Greater Than Target** - Next letter
10. **Kth Missing Positive Number** - Find kth missing

### **Intermediate Level**
11. **Search in Rotated Sorted Array** - Search in rotated array
12. **Search in Rotated Sorted Array II** - With duplicates
13. **Find Minimum in Rotated Sorted Array** - Find minimum
14. **Find Minimum in Rotated Sorted Array II** - With duplicates
15. **Search a 2D Matrix** - Search in 2D sorted matrix
16. **Search a 2D Matrix II** - Search in partially sorted matrix
17. **Find Peak Element** - Find any peak element
18. **Find Right Interval** - Find right interval for each
19. **Random Pick with Weight** - Weighted random selection
20. **Capacity To Ship Packages Within D Days** - Binary search on answer

### **Advanced Level**
21. **Median of Two Sorted Arrays** - Find median in O(log min(m,n))
22. **Kth Smallest Element in Sorted Matrix** - Find kth smallest
23. **Split Array Largest Sum** - Minimize largest sum
24. **Find K Closest Elements** - Find k closest to target
25. **Smallest Rectangle Enclosing Black Pixels** - Find minimum rectangle
26. **Russian Doll Envelopes** - Maximum nested envelopes
27. **Count of Smaller Numbers After Self** - Count smaller elements
28. **Reverse Pairs** - Count reverse pairs
29. **Count of Range Sum** - Count range sums
30. **Maximum Average Subarray II** - Maximum average of length â‰¥ k

---

## ðŸ”¹ 7. TREE/GRAPH TRAVERSAL (DFS/BFS)

### **Beginner Level - Trees**
1. **Binary Tree Inorder Traversal** - Iterative and recursive
2. **Binary Tree Preorder Traversal** - Iterative and recursive
3. **Binary Tree Postorder Traversal** - Iterative and recursive
4. **Binary Tree Level Order Traversal** - BFS traversal
5. **Maximum Depth of Binary Tree** - Find max depth
6. **Minimum Depth of Binary Tree** - Find min depth
7. **Same Tree** - Check if two trees are same
8. **Symmetric Tree** - Check if tree is symmetric
9. **Path Sum** - Check if path sum exists
10. **Binary Tree Paths** - Find all root to leaf paths

### **Intermediate Level - Trees**
11. **Path Sum II** - Find all paths with target sum
12. **Path Sum III** - Count paths with target sum
13. **Binary Tree Right Side View** - Right side view
14. **Binary Tree Zigzag Level Order** - Zigzag traversal
15. **Flatten Binary Tree to Linked List** - Flatten to linked list
16. **Populating Next Right Pointers** - Connect level nodes
17. **Lowest Common Ancestor** - Find LCA
18. **Binary Tree Maximum Path Sum** - Maximum path sum
19. **Diameter of Binary Tree** - Find diameter
20. **Serialize and Deserialize Binary Tree** - Encode/decode tree

### **Advanced Level - Trees**
21. **Binary Tree Cameras** - Minimum cameras needed
22. **Distribute Coins in Binary Tree** - Minimum moves
23. **House Robber III** - Rob houses in tree
24. **Binary Tree Coloring Game** - Two player game
25. **Recover Binary Search Tree** - Fix swapped nodes
26. **Count Good Nodes in Binary Tree** - Count good nodes
27. **Sum of Distances in Tree** - Sum of distances
28. **Smallest Subtree with All Deepest Nodes** - Find subtree
29. **All Nodes Distance K** - Nodes at distance k
30. **Vertical Order Traversal** - Vertical order with sorting

### **Beginner Level - Graphs**
31. **Number of Islands** - Count connected components
32. **Max Area of Island** - Find maximum island area
33. **Flood Fill** - Implement flood fill
34. **Clone Graph** - Deep clone graph
35. **Course Schedule** - Detect cycle in directed graph
36. **Pacific Atlantic Water Flow** - Water flow problem
37. **Surrounded Regions** - Capture surrounded regions
38. **Number of Provinces** - Count connected components
39. **Keys and Rooms** - Visit all rooms
40. **Find if Path Exists in Graph** - Check path existence

### **Intermediate Level - Graphs**
41. **Course Schedule II** - Topological sorting
42. **Minimum Height Trees** - Find minimum height trees
43. **Word Ladder** - Shortest transformation sequence
44. **Word Ladder II** - All shortest paths
45. **Network Delay Time** - Shortest path (Dijkstra)
46. **Cheapest Flights Within K Stops** - Shortest path with constraint
47. **Redundant Connection** - Find redundant edge (Union Find)
48. **Accounts Merge** - Merge accounts (Union Find)
49. **Most Stones Removed** - Remove maximum stones
50. **Satisfiability of Equality Equations** - Union Find

### **Advanced Level - Graphs**
51. **Alien Dictionary** - Topological sort with graphs
52. **Reconstruct Itinerary** - Eulerian path
53. **Critical Connections** - Find bridges (Tarjan's)
54. **Minimum Cost to Connect All Points** - MST (Kruskal/Prim)
55. **Swim in Rising Water** - Binary search + BFS/DFS
56. **Bus Routes** - Shortest path in complex graph
57. **Sliding Puzzle** - BFS with state space
58. **Open the Lock** - BFS shortest path
59. **Word Search II** - Trie + DFS backtracking
60. **Number of Islands II** - Dynamic connectivity

---

## ðŸ”¹ 8. DYNAMIC PROGRAMMING PATTERN

### **Beginner Level**
1. **Climbing Stairs** - Basic DP recurrence
2. **House Robber** - Linear DP
3. **Maximum Subarray** - Kadane's algorithm
4. **Best Time to Buy and Sell Stock** - Simple DP
5. **Min Cost Climbing Stairs** - Choose optimal path
6. **Range Sum Query - Immutable** - Prefix sums
7. **Counting Bits** - DP with bit manipulation
8. **Is Subsequence** - Simple matching
9. **Pascal's Triangle** - Build triangle
10. **Fibonacci Number** - Classic DP

### **Intermediate Level**
11. **Coin Change** - Unbounded knapsack
12. **Coin Change 2** - Count ways
13. **Longest Increasing Subsequence** - LIS problem
14. **Longest Common Subsequence** - 2D DP
15. **Edit Distance** - String transformation
16. **Unique Paths** - Grid DP
17. **Unique Paths II** - With obstacles
18. **Minimum Path Sum** - Grid path finding
19. **Maximum Product Subarray** - Track min and max
20. **House Robber II** - Circular array

### **Advanced Level**
21. **Best Time to Buy and Sell Stock with Cooldown** - State machine DP
22. **Best Time to Buy and Sell Stock IV** - K transactions
23. **Palindromic Substrings** - Count palindromes
24. **Longest Palindromic Subsequence** - Palindrome DP
25. **Regular Expression Matching** - Complex string matching
26. **Wildcard Matching** - Pattern matching
27. **Interleaving String** - 3D DP
28. **Distinct Subsequences** - Count subsequences
29. **Word Break** - String segmentation
30. **Word Break II** - All possible breaks

### **Expert Level**
31. **Burst Balloons** - Interval DP
32. **Remove Boxes** - 3D DP optimization
33. **Strange Printer** - Interval DP
34. **Minimum Cost to Cut Stick** - Interval DP
35. **Stone Game** - Game theory DP
36. **Predict the Winner** - Minimax DP
37. **Longest Valid Parentheses** - Complex DP
38. **Maximum Rectangle** - 2D DP with histogram
39. **Maximal Square** - 2D DP
40. **Count Different Palindromic Subsequences** - Advanced counting

---

## ðŸ”¹ 9. GREEDY ALGORITHMS PATTERN

### **Beginner Level**
1. **Assign Cookies** - Simple greedy matching
2. **Lemonade Change** - Greedy coin selection
3. **Best Time to Buy and Sell Stock II** - Multiple transactions
4. **Jump Game** - Greedy reachability
5. **Jump Game II** - Minimum jumps
6. **Non-overlapping Intervals** - Interval scheduling
7. **Merge Intervals** - Interval merging
8. **Insert Interval** - Insert and merge
9. **Meeting Rooms** - Check if possible
10. **Meeting Rooms II** - Minimum rooms needed

### **Intermediate Level**
11. **Gas Station** - Circular array greedy
12. **Candy** - Two-pass greedy
13. **Task Scheduler** - Scheduling with cooldown
14. **Partition Labels** - Greedy partitioning
15. **Queue Reconstruction by Height** - Greedy reconstruction
16. **Minimum Number of Arrows** - Interval shooting
17. **Non-decreasing Array** - Array modification
18. **Monotone Increasing Digits** - Number modification
19. **Remove K Digits** - Greedy digit removal
20. **Wiggle Subsequence** - Alternating sequence

### **Advanced Level**
21. **Course Schedule III** - Advanced scheduling
22. **Maximum Performance of Team** - Heap + greedy
23. **Minimum Cost to Hire K Workers** - Complex optimization
24. **Campus Bikes** - Bipartite matching greedy
25. **Advantage Shuffle** - Greedy matching strategy
26. **Boats to Save People** - Two pointers greedy
27. **Bag of Tokens** - Greedy token strategy
28. **Minimize Malware Spread** - Graph + greedy
29. **Hand of Straights** - Consecutive grouping
30. **Smallest Range Covering Elements** - Multi-array greedy

---

## ðŸ”¹ 10. BACKTRACKING PATTERN

### **Beginner Level**
1. **Generate Parentheses** - Generate valid combinations
2. **Letter Combinations of Phone Number** - Generate combinations
3. **Combinations** - Choose k from n
4. **Combination Sum** - Sum with repetition allowed
5. **Combination Sum II** - No repetition, with duplicates
6. **Permutations** - Generate all permutations
7. **Permutations II** - With duplicate elements
8. **Subsets** - Generate all subsets
9. **Subsets II** - With duplicate elements
10. **Binary Watch** - Generate valid times

### **Intermediate Level**
11. **Word Search** - Find word in grid
12. **Palindrome Partitioning** - Partition into palindromes
13. **Restore IP Addresses** - Generate valid IP addresses
14. **Combination Sum III** - K numbers sum to n
15. **Factor Combinations** - Find factor combinations
16. **Beautiful Arrangement** - Count beautiful arrangements
17. **Additive Number** - Check if additive sequence
18. **Split into Fibonacci Sequence** - Split string into Fibonacci
19. **Partition to K Equal Sum Subsets** - Partition array
20. **Matchsticks to Square** - Form square with matchsticks

### **Advanced Level**
21. **N-Queens** - Place n queens on chessboard
22. **N-Queens II** - Count solutions
23. **Sudoku Solver** - Solve Sudoku puzzle
24. **Word Search II** - Find multiple words (Trie + backtracking)
25. **Remove Invalid Parentheses** - Remove minimum parentheses
26. **Expression Add Operators** - Add operators to reach target
27. **Different Ways to Add Parentheses** - Evaluate expressions
28. **Unique Paths III** - Path visiting all squares
29. **Flip Game II** - Game theory backtracking
30. **Android Unlock Patterns** - Count unlock patterns

---

## ðŸ”¹ 11. ADVANCED PATTERNS & DATA STRUCTURES

### **Trie (Prefix Tree)**
1. **Implement Trie** - Basic trie implementation
2. **Add and Search Word** - Wildcard search
3. **Word Search II** - Multiple word search
4. **Replace Words** - Replace with root words
5. **Map Sum Pairs** - Sum with prefix
6. **Maximum XOR of Two Numbers** - XOR trie
7. **Concatenated Words** - Words from other words
8. **Palindrome Pairs** - Find palindrome pairs
9. **Stream of Characters** - Query stream
10. **Design Search Autocomplete** - Auto-complete system

### **Union Find (Disjoint Set)**
1. **Number of Islands** - Connected components
2. **Redundant Connection** - Find cycle edge
3. **Accounts Merge** - Merge connected accounts
4. **Most Stones Removed** - Remove connected stones
5. **Number of Operations to Make Network Connected** - Connectivity
6. **Satisfiability of Equality Equations** - Check equations
7. **Regions Cut by Slashes** - Grid connectivity
8. **Largest Component Size by Common Factor** - Factor connectivity
9. **Couples Holding Hands** - Minimum swaps
10. **Number of Islands II** - Dynamic islands

### **Segment Tree / Fenwick Tree**
1. **Range Sum Query - Mutable** - Range sum with updates
2. **Range Sum Query 2D - Mutable** - 2D range sum
3. **Count of Smaller Numbers After Self** - Inversion count
4. **Reverse Pairs** - Count reverse pairs
5. **Count of Range Sum** - Range sum count
6. **The Skyline Problem** - Skyline with segment tree
7. **Falling Squares** - Maximum height tracking
8. **My Calendar III** - K-booking problem
9. **Number of Longest Increasing Subsequence** - LIS count
10. **Maximum Sum Rectangle No Larger Than K** - 2D optimization

### **Advanced Graph Algorithms**
1. **Network Delay Time** - Dijkstra's shortest path
2. **Cheapest Flights Within K Stops** - Bellman-Ford variant
3. **Find Critical and Pseudo-Critical Edges** - MST analysis
4. **Minimum Cost to Connect All Points** - MST (Prim/Kruskal)
5. **Critical Connections in Network** - Tarjan's bridges
6. **Strongly Connected Components** - Tarjan's/Kosaraju's
7. **Shortest Path Visiting All Nodes** - TSP variant
8. **Bus Routes** - Multi-layer BFS
9. **Swim in Rising Water** - Binary search + connectivity
10. **Minimum Cost to Make at Least One Valid Path** - Modified Dijkstra

---

## ðŸŽ¯ MASTERY CHECKLIST

### **Pattern Recognition Speed Test**
- Can identify the correct pattern within 30 seconds
- Can write the template code from memory
- Can adapt the pattern to variations

### **Implementation Benchmarks**
- **Beginner**: Solve with hints and template
- **Intermediate**: Solve independently with pattern knowledge
- **Advanced**: Optimize time/space complexity
- **Expert**: Handle edge cases and variants

### **Real-World Application**
- Use patterns in system design problems
- Combine multiple patterns in complex problems
- Optimize for production constraints (memory, latency)

---

## ðŸš€ PRACTICE STRATEGY

### **Week 1-2: Pattern Foundation**
- Focus on one pattern per day
- Solve 5 beginner problems per pattern
- Master the template code

### **Week 3-4: Pattern Application**
- Solve intermediate problems
- Practice pattern recognition
- Time yourself on easy problems

### **Week 5-6: Advanced Mastery**
- Tackle advanced problems
- Combine multiple patterns
- Focus on optimization

### **Week 7-8: Interview Simulation**
- Random problem selection
- 45-minute time limits
- Explain your approach out loud

This comprehensive list covers every major coding pattern and difficulty level. Master these, and you'll be ready for any technical interview or real-world engineering challenge!
